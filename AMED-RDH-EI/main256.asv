clear
clc
num = 10000000;
rand('seed',0); %设置种子
D = round(rand(1,num)*1); %产生稳定随机数产生秘密
%% 设置图像加密密钥及数据加密密钥
Image_key = 1; 
Data_key = 2;
%% 设置参数(方便实验修改)
ref_x = 1; %用来作为参考像素的行数
ref_y = 1; %用来作为参考像素的列数
%% 图像加密及数据嵌入&&&&&改I11（一个图像4次）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%I = imread('测试图像\Airplane.tiff');
I = imread('测试图像\Lena.tiff');
 % I = imread('测试图像\Man.tiff');
% I = imread('测试图像\Jetplane.tiff');
% I = imread('测试图像\Baboon.tiff');
% I = imread('测试图像\Tiffany.tiff');
origin_I = double(I); 
[M,N] = size(origin_I);
I11=zeros(32,32);
I12=zeros(32,33);
I13=zeros(33,32);
I14=zeros(33,33);
maxmapzong=zeros(1,9);%%每个标记的数量
A=cell(16,16);
B=cell(16,16);
qianrulu=0;
for i=1:16
    for j=1:16%这一级是分块矩阵
        for i1=1:32
            for j1=1:32
                I11(i1,j1)=origin_I(i1+(i-1)*32,j1+(j-1)*32);
            end
        end
       
        if i==1&&j>1%分成四个部分
            for i2=1:32
                for j2=1:32
                    I12(i2,j2+1)=I11(i2,j2);
                    A{i,j}=I12;
                end
            end
        elseif i>1&&j==1
            for i2=1:32
                for j2=1:32
                    I13(i2+1,j2)=I11(i2,j2);
                    A{i,j}=I13;
                end
            end
        elseif i>1&&j>1
            for i2=1:32
                for j2=1:32
                    I14(i2+1,j2+1)=I11(i2,j2);
                    A{i,j}=I14;
                end
            end
        else A{i,j}=I11;
        end

    end
end
k11_1=0;
k11_3=0;
k11_2=0;
for i=1:16%%开始求那个最大原始嵌入率
    for j=1:16
maxemD11=[1];
        for q3=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,0,q3);
if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_3=q3;
end
        end
           for q2=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,q2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_2=q2;
end
           end
             for q1=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,q1,k11_2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_1=q1;
end
             end
            % B{i,j}=size(maxemD11, 2)+52;最大原始嵌入率
%qianrulu=size(maxemD11, 2)+52+qianrulu;
[M2,N2]=size(maxhist_Map_origin_I11)
 for i4=1:M2
     if maxhist_Map_origin_I11(i4,1)==0
       maxmapzong(1,1)=maxmapzong(1,1)+maxhist_Map_origin_I11(i4,2);
     elseif maxhist_Map_origin_I11(i4,1)==1
       maxmapzong(1,2)=maxmapzong(1,2)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==2
       maxmapzong(1,3)=maxmapzong(1,3)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==3
       maxmapzong(1,4)=maxmapzong(1,4)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==4
       maxmapzong(1,5)=maxmapzong(1,5)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==5
       maxmapzong(1,6)=maxmapzong(1,6)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==6
       maxmapzong(1,7)=maxmapzong(1,7)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==7
       maxmapzong(1,8)=maxmapzong(1,8)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==8
       maxmapzong(1,9)=maxmapzong(1,9)+maxhist_Map_origin_I11(i4,2);
     end
 end
    end
end
save('lena256.mat');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear
clc
num = 10000000;
rand('seed',0); %设置种子
D = round(rand(1,num)*1); %产生稳定随机数产生秘密
%% 设置图像加密密钥及数据加密密钥
Image_key = 1; 
Data_key = 2;
%% 设置参数(方便实验修改)
ref_x = 1; %用来作为参考像素的行数
ref_y = 1; %用来作为参考像素的列数
%% 图像加密及数据嵌入&&&&&改I11（一个图像4次）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
I = imread('测试图像\Airplane.tiff');
%I = imread('测试图像\Lena.tiff');
 % I = imread('测试图像\Man.tiff');
% I = imread('测试图像\Jetplane.tiff');
% I = imread('测试图像\Baboon.tiff');
% I = imread('测试图像\Tiffany.tiff');
origin_I = double(I); 
[M,N] = size(origin_I);
I11=zeros(32,32);
I12=zeros(32,33);
I13=zeros(33,32);
I14=zeros(33,33);
maxmapzong=zeros(1,9);%%每个标记的数量
A=cell(16,16);
B=cell(16,16);
qianrulu=0;
for i=1:16
    for j=1:16%这一级是分块矩阵
        for i1=1:32
            for j1=1:32
                I11(i1,j1)=origin_I(i1+(i-1)*32,j1+(j-1)*32);
            end
        end
       
        if i==1&&j>1%分成四个部分
            for i2=1:32
                for j2=1:32
                    I12(i2,j2+1)=I11(i2,j2);
                    A{i,j}=I12;
                end
            end
        elseif i>1&&j==1
            for i2=1:32
                for j2=1:32
                    I13(i2+1,j2)=I11(i2,j2);
                    A{i,j}=I13;
                end
            end
        elseif i>1&&j>1
            for i2=1:32
                for j2=1:32
                    I14(i2+1,j2+1)=I11(i2,j2);
                    A{i,j}=I14;
                end
            end
        else A{i,j}=I11;
        end

    end
end
k11_1=0;
k11_3=0;
k11_2=0;
for i=1:16%%开始求那个最大原始嵌入率
    for j=1:16
maxemD11=[1];
        for q3=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,0,q3);
if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_3=q3;
end
        end
           for q2=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,q2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_2=q2;
end
           end
             for q1=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,q1,k11_2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_1=q1;
end
             end
            % B{i,j}=size(maxemD11, 2)+52;最大原始嵌入率
%qianrulu=size(maxemD11, 2)+52+qianrulu;
[M2,N2]=size(maxhist_Map_origin_I11)
 for i4=1:M2
     if maxhist_Map_origin_I11(i4,1)==0
       maxmapzong(1,1)=maxmapzong(1,1)+maxhist_Map_origin_I11(i4,2);
     elseif maxhist_Map_origin_I11(i4,1)==1
       maxmapzong(1,2)=maxmapzong(1,2)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==2
       maxmapzong(1,3)=maxmapzong(1,3)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==3
       maxmapzong(1,4)=maxmapzong(1,4)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==4
       maxmapzong(1,5)=maxmapzong(1,5)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==5
       maxmapzong(1,6)=maxmapzong(1,6)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==6
       maxmapzong(1,7)=maxmapzong(1,7)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==7
       maxmapzong(1,8)=maxmapzong(1,8)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==8
       maxmapzong(1,9)=maxmapzong(1,9)+maxhist_Map_origin_I11(i4,2);
     end
 end
    end
end
save('airplan256.mat');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear
clc
num = 10000000;
rand('seed',0); %设置种子
D = round(rand(1,num)*1); %产生稳定随机数产生秘密
%% 设置图像加密密钥及数据加密密钥
Image_key = 1; 
Data_key = 2;
%% 设置参数(方便实验修改)
ref_x = 1; %用来作为参考像素的行数
ref_y = 1; %用来作为参考像素的列数
%% 图像加密及数据嵌入&&&&&改I11（一个图像4次）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%I = imread('测试图像\Airplane.tiff');
%I = imread('测试图像\Lena.tiff');
 % I = imread('测试图像\Man.tiff');
 I = imread('测试图像\Jetplane.tiff');
% I = imread('测试图像\Baboon.tiff');
% I = imread('测试图像\Tiffany.tiff');
origin_I = double(I); 
[M,N] = size(origin_I);
I11=zeros(32,32);
I12=zeros(32,33);
I13=zeros(33,32);
I14=zeros(33,33);
maxmapzong=zeros(1,9);%%每个标记的数量
A=cell(16,16);
B=cell(16,16);
qianrulu=0;
for i=1:16
    for j=1:16%这一级是分块矩阵
        for i1=1:32
            for j1=1:32
                I11(i1,j1)=origin_I(i1+(i-1)*32,j1+(j-1)*32);
            end
        end
       
        if i==1&&j>1%分成四个部分
            for i2=1:32
                for j2=1:32
                    I12(i2,j2+1)=I11(i2,j2);
                    A{i,j}=I12;
                end
            end
        elseif i>1&&j==1
            for i2=1:32
                for j2=1:32
                    I13(i2+1,j2)=I11(i2,j2);
                    A{i,j}=I13;
                end
            end
        elseif i>1&&j>1
            for i2=1:32
                for j2=1:32
                    I14(i2+1,j2+1)=I11(i2,j2);
                    A{i,j}=I14;
                end
            end
        else A{i,j}=I11;
        end

    end
end
k11_1=0;
k11_3=0;
k11_2=0;
for i=1:16%%开始求那个最大原始嵌入率
    for j=1:16
maxemD11=[1];
        for q3=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,0,q3);
if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_3=q3;
end
        end
           for q2=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,q2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_2=q2;
end
           end
             for q1=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,q1,k11_2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_1=q1;
end
             end
            % B{i,j}=size(maxemD11, 2)+52;最大原始嵌入率
%qianrulu=size(maxemD11, 2)+52+qianrulu;
[M2,N2]=size(maxhist_Map_origin_I11)
 for i4=1:M2
     if maxhist_Map_origin_I11(i4,1)==0
       maxmapzong(1,1)=maxmapzong(1,1)+maxhist_Map_origin_I11(i4,2);
     elseif maxhist_Map_origin_I11(i4,1)==1
       maxmapzong(1,2)=maxmapzong(1,2)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==2
       maxmapzong(1,3)=maxmapzong(1,3)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==3
       maxmapzong(1,4)=maxmapzong(1,4)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==4
       maxmapzong(1,5)=maxmapzong(1,5)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==5
       maxmapzong(1,6)=maxmapzong(1,6)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==6
       maxmapzong(1,7)=maxmapzong(1,7)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==7
       maxmapzong(1,8)=maxmapzong(1,8)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==8
       maxmapzong(1,9)=maxmapzong(1,9)+maxhist_Map_origin_I11(i4,2);
     end
 end
    end
end
save('jetplan256.mat');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear
clc
num = 10000000;
rand('seed',0); %设置种子
D = round(rand(1,num)*1); %产生稳定随机数产生秘密
%% 设置图像加密密钥及数据加密密钥
Image_key = 1; 
Data_key = 2;
%% 设置参数(方便实验修改)
ref_x = 1; %用来作为参考像素的行数
ref_y = 1; %用来作为参考像素的列数
%% 图像加密及数据嵌入&&&&&改I11（一个图像4次）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%I = imread('测试图像\Airplane.tiff');
%I = imread('测试图像\Lena.tiff');
 % I = imread('测试图像\Man.tiff');
% I = imread('测试图像\Jetplane.tiff');
 I = imread('测试图像\Baboon.tiff');
% I = imread('测试图像\Tiffany.tiff');
origin_I = double(I); 
[M,N] = size(origin_I);
I11=zeros(32,32);
I12=zeros(32,33);
I13=zeros(33,32);
I14=zeros(33,33);
maxmapzong=zeros(1,9);%%每个标记的数量
A=cell(16,16);
B=cell(16,16);
qianrulu=0;
for i=1:16
    for j=1:16%这一级是分块矩阵
        for i1=1:32
            for j1=1:32
                I11(i1,j1)=origin_I(i1+(i-1)*32,j1+(j-1)*32);
            end
        end
       
        if i==1&&j>1%分成四个部分
            for i2=1:32
                for j2=1:32
                    I12(i2,j2+1)=I11(i2,j2);
                    A{i,j}=I12;
                end
            end
        elseif i>1&&j==1
            for i2=1:32
                for j2=1:32
                    I13(i2+1,j2)=I11(i2,j2);
                    A{i,j}=I13;
                end
            end
        elseif i>1&&j>1
            for i2=1:32
                for j2=1:32
                    I14(i2+1,j2+1)=I11(i2,j2);
                    A{i,j}=I14;
                end
            end
        else A{i,j}=I11;
        end

    end
end
k11_1=0;
k11_3=0;
k11_2=0;
for i=1:16%%开始求那个最大原始嵌入率
    for j=1:16
maxemD11=[1];
        for q3=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,0,q3);
if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_3=q3;
end
        end
           for q2=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,q2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_2=q2;
end
           end
             for q1=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,q1,k11_2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_1=q1;
end
             end
            % B{i,j}=size(maxemD11, 2)+52;最大原始嵌入率
%qianrulu=size(maxemD11, 2)+52+qianrulu;
[M2,N2]=size(maxhist_Map_origin_I11)
 for i4=1:M2
     if maxhist_Map_origin_I11(i4,1)==0
       maxmapzong(1,1)=maxmapzong(1,1)+maxhist_Map_origin_I11(i4,2);
     elseif maxhist_Map_origin_I11(i4,1)==1
       maxmapzong(1,2)=maxmapzong(1,2)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==2
       maxmapzong(1,3)=maxmapzong(1,3)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==3
       maxmapzong(1,4)=maxmapzong(1,4)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==4
       maxmapzong(1,5)=maxmapzong(1,5)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==5
       maxmapzong(1,6)=maxmapzong(1,6)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==6
       maxmapzong(1,7)=maxmapzong(1,7)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==7
       maxmapzong(1,8)=maxmapzong(1,8)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==8
       maxmapzong(1,9)=maxmapzong(1,9)+maxhist_Map_origin_I11(i4,2);
     end
 end
    end
end
save('baboon256.mat');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear
clc
num = 10000000;
rand('seed',0); %设置种子
D = round(rand(1,num)*1); %产生稳定随机数产生秘密
%% 设置图像加密密钥及数据加密密钥
Image_key = 1; 
Data_key = 2;
%% 设置参数(方便实验修改)
ref_x = 1; %用来作为参考像素的行数
ref_y = 1; %用来作为参考像素的列数
%% 图像加密及数据嵌入&&&&&改I11（一个图像4次）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%I = imread('测试图像\Airplane.tiff');
%I = imread('测试图像\Lena.tiff');
 % I = imread('测试图像\Man.tiff');
% I = imread('测试图像\Jetplane.tiff');
% I = imread('测试图像\Baboon.tiff');
 I = imread('测试图像\Tiffany.tiff');
origin_I = double(I); 
[M,N] = size(origin_I);
I11=zeros(32,32);
I12=zeros(32,33);
I13=zeros(33,32);
I14=zeros(33,33);
maxmapzong=zeros(1,9);%%每个标记的数量
A=cell(16,16);
B=cell(16,16);
qianrulu=0;
for i=1:16
    for j=1:16%这一级是分块矩阵
        for i1=1:32
            for j1=1:32
                I11(i1,j1)=origin_I(i1+(i-1)*32,j1+(j-1)*32);
            end
        end
       
        if i==1&&j>1%分成四个部分
            for i2=1:32
                for j2=1:32
                    I12(i2,j2+1)=I11(i2,j2);
                    A{i,j}=I12;
                end
            end
        elseif i>1&&j==1
            for i2=1:32
                for j2=1:32
                    I13(i2+1,j2)=I11(i2,j2);
                    A{i,j}=I13;
                end
            end
        elseif i>1&&j>1
            for i2=1:32
                for j2=1:32
                    I14(i2+1,j2+1)=I11(i2,j2);
                    A{i,j}=I14;
                end
            end
        else A{i,j}=I11;
        end

    end
end
k11_1=0;
k11_3=0;
k11_2=0;
for i=1:16%%开始求那个最大原始嵌入率
    for j=1:16
maxemD11=[1];
        for q3=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,0,q3);
if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_3=q3;
end
        end
           for q2=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,q2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_2=q2;
end
           end
             for q1=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,q1,k11_2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_1=q1;
end
             end
            % B{i,j}=size(maxemD11, 2)+52;最大原始嵌入率
%qianrulu=size(maxemD11, 2)+52+qianrulu;
[M2,N2]=size(maxhist_Map_origin_I11)
 for i4=1:M2
     if maxhist_Map_origin_I11(i4,1)==0
       maxmapzong(1,1)=maxmapzong(1,1)+maxhist_Map_origin_I11(i4,2);
     elseif maxhist_Map_origin_I11(i4,1)==1
       maxmapzong(1,2)=maxmapzong(1,2)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==2
       maxmapzong(1,3)=maxmapzong(1,3)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==3
       maxmapzong(1,4)=maxmapzong(1,4)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==4
       maxmapzong(1,5)=maxmapzong(1,5)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==5
       maxmapzong(1,6)=maxmapzong(1,6)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==6
       maxmapzong(1,7)=maxmapzong(1,7)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==7
       maxmapzong(1,8)=maxmapzong(1,8)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==8
       maxmapzong(1,9)=maxmapzong(1,9)+maxhist_Map_origin_I11(i4,2);
     end
 end
    end
end
save('tiff256.mat');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
clear
clc
num = 10000000;
rand('seed',0); %设置种子
D = round(rand(1,num)*1); %产生稳定随机数产生秘密
%% 设置图像加密密钥及数据加密密钥
Image_key = 1; 
Data_key = 2;
%% 设置参数(方便实验修改)
ref_x = 1; %用来作为参考像素的行数
ref_y = 1; %用来作为参考像素的列数
%% 图像加密及数据嵌入&&&&&改I11（一个图像4次）
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%I = imread('测试图像\Airplane.tiff');
%I = imread('测试图像\Lena.tiff');
  I = imread('测试图像\Man.tiff');
% I = imread('测试图像\Jetplane.tiff');
% I = imread('测试图像\Baboon.tiff');
% I = imread('测试图像\Tiffany.tiff');
origin_I = double(I); 
[M,N] = size(origin_I);
I11=zeros(64,64);
I12=zeros(64,65);
I13=zeros(65,64);
I14=zeros(65,65);
maxmapzong=zeros(1,9);%%每个标记的数量
A=cell(16,16);
B=cell(16,16);
qianrulu=0;
for i=1:16
    for j=1:16%这一级是分块矩阵
        for i1=1:64
            for j1=1:64
                I11(i1,j1)=origin_I(i1+(i-1)*64,j1+(j-1)*64);
            end
        end
       
        if i==1&&j>1%分成四个部分
            for i2=1:64
                for j2=1:64
                    I12(i2,j2+1)=I11(i2,j2);
                    A{i,j}=I12;
                end
            end
        elseif i>1&&j==1
            for i2=1:64
                for j2=1:64
                    I13(i2+1,j2)=I11(i2,j2);
                    A{i,j}=I13;
                end
            end
        elseif i>1&&j>1
            for i2=1:64
                for j2=1:64
                    I14(i2+1,j2+1)=I11(i2,j2);
                    A{i,j}=I14;
                end
            end
        else A{i,j}=I11;
        end

    end
end
k11_1=0;
k11_3=0;
k11_2=0;
for i=1:16%%开始求那个最大原始嵌入率
    for j=1:16
maxemD11=[1];
        for q3=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,0,q3);
if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_3=q3;
end
        end
           for q2=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,0,q2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_2=q2;
end
           end
             for q1=-3:1:4
[encrypt_I,stego_I,emD,hist_Map_origin_I] = Encrypt_Embed(A{i,j},D,Image_key,Data_key,ref_x,ref_y,q1,k11_2,k11_3);

if size(emD, 2)>size(maxemD11, 2)
    maxemD11=emD;
    maxhist_Map_origin_I11=hist_Map_origin_I;
    k11_1=q1;
end
             end
            % B{i,j}=size(maxemD11, 2)+52;最大原始嵌入率
%qianrulu=size(maxemD11, 2)+52+qianrulu;
[M2,N2]=size(maxhist_Map_origin_I11)
 for i4=1:M2
     if maxhist_Map_origin_I11(i4,1)==0
       maxmapzong(1,1)=maxmapzong(1,1)+maxhist_Map_origin_I11(i4,2);
     elseif maxhist_Map_origin_I11(i4,1)==1
       maxmapzong(1,2)=maxmapzong(1,2)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==2
       maxmapzong(1,3)=maxmapzong(1,3)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==3
       maxmapzong(1,4)=maxmapzong(1,4)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==4
       maxmapzong(1,5)=maxmapzong(1,5)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==5
       maxmapzong(1,6)=maxmapzong(1,6)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==6
       maxmapzong(1,7)=maxmapzong(1,7)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==7
       maxmapzong(1,8)=maxmapzong(1,8)+maxhist_Map_origin_I11(i4,2);
        elseif maxhist_Map_origin_I11(i4,1)==8
       maxmapzong(1,9)=maxmapzong(1,9)+maxhist_Map_origin_I11(i4,2);
     end
 end
    end
end
save('man256.mat');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%